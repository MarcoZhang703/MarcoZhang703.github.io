---
layout:     post
title:      《大话数据结构》读书笔记(1)
subtitle:   基本概念、算法入门、空间时间复杂度
date:       2020-01-22
author:     Marco Cheung
header-img: img/home-bg.jpg
catalog: true
tags:
    - 技术分享
    - 博客

---
<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

## 前言

这是《大话数据结构》的读书笔记，因此**“抄书”的情况不可避**。但我还是坚信好记性不如烂笔头的道理的，而且也确实简化了书中的部分内容方便个人的理解和反查。

## 基本概念与基本术语

### 数据

数据是**描述客观事物的符号**，是计算机中可以操作的对象，是能被计算机识别并输入给计算机处理的符号集合。这些符号具备以下两个前提：

- 可以输入到计算机中
- 能被计算机程序处理
  - 对于整型、实型等数值类型，可以进行数值计算。
  - 对于字符数据类型，要进行非数值处理。而声音、视频、图像是可以用编码手段转换成字符数据进行处理的。

### 数据元素

是组成数据的、有一定意义的基本单位，在计算机中通常作为**整体**处理。例如：

- 在“人类”这个集合中，数据元素是“人”
- 在“家畜”集合中，数据元素是“猪”，“牛”，“羊”，“马”等。

### 数据项

**一个数据元素由若干数据项构成。**，例如“人”作为一个数据元素，

- 性别、年龄、出生日期、联系电话是数据项
- 耳、鼻、喉、手、脚也可以是数据项。
- 具体有哪些数据项，由你设计的系统决定。

**数据项是数据不可分割的最小单位**

### 数据对象

是**性质相同**的数据元素的集合，是数据的子集。

（性质相同：指数据元素具有**相同数量和类型**的数据项）

由于 数据对象 是 数据 的子集，在实际应用中，处理的数据元素通常具有相同性质，**在不产生混淆的情况下，我们都将 数据对象 简称为 数据 。**

### 数据结构

是相互之间存在一种或多种特定关系的数据元素的集合。

结构，即关系，我们说数据结构，一般说的是数据元素之间存在一种或多种特定关系，也就是**数据的组织形式**。

## 逻辑结构与物理结构

### 逻辑结构

- **集合结构**
  - 数据元素仅同属一个集合，没有其他关系。就类似于数学中的集合。
- **线性结构**
  - 数据元素之间是一对一的关系（串联）
- **树形结构**
  - 数据元素存在一种一对多的关系。
- **图形结构**
  - 数据元素是多对多的关系。

### 物理结构

物理结构：**指数据的逻辑结构在计算机中的存储形式**

- 顺序存储结构
- 链式存储结构

## 算法的定义、特性、设计要求和效率的度量方法等

### **算法**：

是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

### **算法的特性**：

**输入、输出、有穷性、确定性、可行性**

- 算法至少有一个或多个输出（即必须要输出），但具有零个或多个输入（即可以无输入）
- **有穷性**：指算法在执行完有限步骤后，自动结束而不会出现无限循环，并且每个步骤在可接受的时间内完成。
- **确定性**：算法的每一步都必须具有确定含义，不会出现二义性。
- **可行性**：算法的每一步都必须是可行的

### 算法的设计要求

- **正确性**（大致分为以下四层次，但论证层次4太过困难，故一般认为层次3为验证一个算法是否正确的标准）
  - 算法程序没有语法错误
  - 算法程序对于合法的输入数据能产生满足要求的输出结果
  - 算法程序对于非法的输入数据能得出满足规格说明的结果
  - 算法程序对于精心选择的、甚至刁难的测试数据都有满足要求的输出结果
- **可读性**：便于阅读、理解和交流
- **健壮性**：当输入数据不合法时，算法也能做出相关处理，而非产生异常或莫名其妙的结果
- **时间效率高和存储量低**

### 算法效率的度量方法

- **事后统计方法**
  - 主要通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。
  - **缺陷**：
    - 必须依据算法事先编制好程序
    - 时间的比较依赖于计算机软硬件因素，高性能平台往往会掩盖算法的优劣
    - 算法的测试数据设计困难，并且程序的运行时间往往还与测试数据的规模有很大关系。如何去确定数据集的范围，是很难判断的
  - 综上，我们不采用具有诸多缺陷的事后统计方法。
- **事前分析估计方法**
  - 在计算机程序编制前，依据统计方法对算法进行估算。
  - 程序在计算机上运行的用时主要取决于：
    - 算法采用的策略、方法（是算法好坏的根本）
    - 编译产生的代码质量（由软件支持）
    - **问题的输入规模**（指输入量的多少）
    - 机器执行指令的速度（看硬件性能）

### 函数的渐进式增长

- 例子1

|  n   | Algorithm A (2n+3) | Algorithm B (3n+1) |
| :--: | :----------------: | :----------------: |
|  1   |         5          |         4          |
|  2   |         7          |         7          |
|  3   |         9          |         10         |
|  10  |         23         |         31         |
| 100  |        203         |        301         |
| 1000 |        2003        |        3001        |

当n较小时，可以看到算法A效率不如算法B，当n开始增大时，算法A开始优于算法B。于是得出结论，**总体而言**，算法A 优于 算法B。

给出定义：输入规模n在无限制的情况下，只要超过一个数值时，这个函数总大于另一个函数，我们称函数是**渐进式增长**的，

**观察得**，随着n的增大，后面+3、+1等加法常数不影响最终算法变化和性能比较。

- 例子2

|  n   | Algorithm A (4n+8) | Algorithm B ($2n^2+1$) |
| :--: | :----------------: | :--------------------: |
|  1   |         12         |           3            |
|  2   |         16         |           9            |
|  3   |         20         |           19           |
|  10  |         48         |          201           |
| 100  |        408         |         20001          |
| 1000 |        4008        |        2000001         |

观察得，去掉后面加法常数，比较结果无变化。**去掉与n相乘的系数**，比较结果亦无变化。

- 例子3

|  n   | Algorithm A ($2n^2+3n+1$) | Algorithm B ($2n^3+3n+1$) |
| :--: | :-----------------------: | :-----------------------: |
|  1   |             6             |             6             |
|  2   |            15             |            23             |
|  3   |            28             |            64             |
|  10  |            231            |           2031            |
| 100  |           20301           |          2000301          |

观察得，**最高次项的指数大**的算法，函数随着n的增长，结果也会增长的特别快。

- 例子4

|    n    | Algorithm A ($2n^2$) | Algorithm B ($3n+1$) | Algorithm C ($2n^2+3n+1$) |
| :-----: | :------------------: | :------------------: | :-----------------------: |
|    1    |          2           |          4           |             6             |
|    2    |          8           |          7           |            15             |
|   10    |         200          |          31          |            231            |
|   100   |        20 000        |         301          |           20301           |
|  1000   |      2 000 000       |         3001         |          2003001          |
|  10000  |     200 000 000      |        30001         |         200030001         |
| 100 000 |    20 000 000 000    |        300001        |        20000300001        |
| 1000000 |    2000000000000     |       3000001        |       2000003000001       |

观察得，**当n的值非常大时**，算法C和A已经很趋近。因此得出结论：**判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。**

以上其实就是事前估算方法的理论依据：**通过算法时间复杂度来估算算法时间效率**。

### 算法时间复杂度

**定义**：进行算法分析时，语句总执行次数T(n)是关于输入规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。

算法的时间复杂度（又称算法时间量度）记作：$T(n) = O(f(n))$。 

用大写 $O()$ 来体现算法时间复杂度的记法，称为**大O记法**。它表示：随输入规模n的增大，**算法执行时间的增长率**和   $f(n)$  的增长率相同。

- 一般而言，随n的增大，T(n)增长最慢的算法为最优算法。
- **常见的时间复杂度**
  - O(1)叫常数阶，O(n)叫线性阶，$O(n^2)$为平方阶，O(log n)为对数阶，O(nlog n)为nlogn阶，$O(n^3)$为立方阶，$O(n^n)$为指数阶。
  - 常用时间复杂度**所耗费的时间**从小到大排序：
  - O(1) < O(log n) < O(n) < O(nlog n) < $O(n^2)$ < $O(n^3)$ <  $O(2^n)$ < $O(n^n)$
- **推导得出大O阶的办法：**
  - 用常数1取代运行时间中的所有加法常数
  - 在修改后的运行次数函数中，只保留最高阶项
  - 若最高阶项存在且不是1，则去除与这个项相乘的常数
  - 得到大O阶结果
- **推导大O阶的例子：算法执行次数表达函数为$\frac{(n-1)}{2}$**
  - 表达函数化简为：$\frac{1}{2}n-\frac{1}{2}$
  - Step 1: 函数化为：$\frac{1}{2}n-1$
  - Step2: 函数化为：$\frac{1}{2}n$
  - Step3: 函数化为：$n$
  - 综上，大O阶结果（即该算法的时间复杂度）为：O(n)

- **由代码推导大O阶：以对数阶为例**

```c
int count = 1;
while (count < n){
	count = count * 2;
	/* Algorithm at O(1) */
}
```

由于每次count乘以2后就离n更近一步，也就是说，当有x个2相乘后count会大于n，则会退出循环。即：$2^x = n$得到$x = log_2 n$。所以这个循环的时间复杂度为$O(log n)$。

- **复杂语句的大O阶推导：以循环嵌套、方法调用为例**

  ```c
  n++;                         //执行次数为1
  function(n);                 //执行次数为n
  int i, j;
  for(i = 0; i < n; i ++){     //执行次数为n^2
  	function(i);
  }
  for(i = 0; i < n; i ++){     //执行次数为n(n + 1) / 2
  	for(j = i; j < n; j ++){
  		/* Algorithm at O(1) */
  	}
  }
  ```

  该代码的执行次数为：$f(n)=1+n+n^2+\frac{n(n+1)}{2}=\frac{3}{2}n^2+\frac{3}{2}n+1$ 

  根据大O阶推导方法，这段代码的时间复杂度也是$O(n^2)$

### 最坏情况与平均情况

最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的需求，除非特别指定，**通常我们提到的运行时间都是最坏情况的运行时间**。

**平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。**也就是说，我们运行一段程序代码时，是希望看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。

对算法的分析，**一种方法**是计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。**另一种方法**是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂度。**一般在没有特殊说明的情况下，都是指最坏时间复杂度。**

### 算法空间复杂度

- 采取用空间换时间的策略：以判断闰年为例
  - 时间复杂度高：写一个判断闰年的算法。
  - 空间复杂度高：把1900到2099年所有的闰年年份都存进去。
- 空间复杂度和时间复杂度的取舍主要看程序用途和设计目标，见仁见智。
- 算法空间复杂度的计算公式：<img src="https://www.zhihu.com/equation?tex=S(n)=O(f(n))" />
- n为问题的规模，f(n)为语句关于n所占存储空间的函数。

## 结语

算法是很重要的。搞清楚算法的时间复杂度估算，也是很重要的。这可以让开发者明白自己的代码效率是否满足性能需求，同时判断进一步优化的可能性。

CPU愈来愈快，真的能抛开算法吗？不能。

假设CPU性能提高100倍，而我们的某个算法本可以写出时间复杂度是 O (n）的程序，却写出了 $O (n^2）$的程序，仅仅因为容易想到，也容易写。即在$O (n^2）$的时间复杂度算法程序下，速度其实只提高了 10 倍（$\sqrt{100}=10$），而对于 O (n）时间复杂度的算法来说，那才是真的 100 倍。

也就是说，当一台基于旧CPU的计算机运行O(n)的程序，和搭载新CPU的计算机运行$O(n^2)$的程序，有可能前者获胜。